# [vector и алгоритмы](../readme.md)

## Алгоритмы

Решение алгоритмических задач в C++ включает несколько ключевых аспектов, включая правильное использование структур
данных, алгоритмов и анализ времени выполнения с помощью нотации Big O.

* ### Структуры данных:

    * Массивы (arrays): Удобны для хранения последовательных элементов, но доступ к элементам осуществляется за
      константное
      время, O(1), только если известен индекс элемента.
    * Строки (strings): Массивы символов, которые поддерживают различные операции работы со строками. Изменение символа
      по
      индексу может иметь сложность O(1), но вставка и удаление символов могут иметь сложность O(n).
    * Списки (lists): Позволяют эффективно вставлять и удалять элементы в середине списка, но доступ к элементам требует
      O(n)
      времени, так как необходимо последовательно пройти по всему списку.

* ### Алгоритмы:

    * Сортировка (sorting): Одной из самых распространенных задач является сортировка данных. Различные алгоритмы
      сортировки
      имеют разную производительность, например, сортировка пузырьком имеет сложность O(n^2), а сортировка слиянием - O(
      n log
      n).
    * Поиск (searching): Поиск элемента в структуре данных может быть выполнен с использованием различных алгоритмов,
      таких
      как линейный поиск (O(n)) и бинарный поиск (O(log n)), предполагая, что данные отсортированы.

### Big O:

Big O (O-нотация) используется для описания временной сложности алгоритма и его зависимости от размера входных данных.
Например, O(1) означает постоянное время выполнения, O(n) - линейную зависимость, O(n^2) - квадратичную зависимость и
так далее.

Big O также используется для оценки объема потребляемой памяти алгоритмом. Например, O(1) означает постоянное
использование памяти, O(n) - линейную зависимость и O(n^2) - квадратичную зависимость.

Анализ времени выполнения алгоритмов с помощью Big O позволяет оценить их эффективность и выбрать наиболее подходящий
алгоритм для конкретной задачи. Например, если у вас есть большой массив данных и требуется выполнить поиск,
использование алгоритма с линейной сложностью может быть непрактичным, и лучше выбрать алгоритм с логарифмической
сложностью.

Важно помнить, что Big O является асимптотической оценкой, описывающей поведение алгоритма при стремлении размера
входных данных к бесконечности. Реальное время выполнения может быть отличным от оценки в Big O, особенно для малых
размеров входных данных или при наличии факторов, не учтенных в анализе сложности.

Оценка сложности алгоритмов с помощью Big O включает определение, как время выполнения алгоритма или используемая память
меняются в зависимости от размера входных данных. Для оценки сложности алгоритма, следуйте этим шагам:

1. Определите размер входных данных: Определите, какой параметр будет служить мерой размера входных данных. Например, для
массива это может быть длина массива, для строки - длина строки.

2. Определите базовые операции: Определите основные операции, которые выполняются внутри алгоритма. Например, доступ к
элементу массива, выполнение арифметических операций, вызов функций и т.д.

3. Оцените количество операций: Определите, сколько раз выполняются базовые операции в зависимости от размера входных
данных. Игнорируйте константные множители и сохраните только доминирующий член. Например, если цикл выполняется n раз, а
внутри цикла есть операции с линейной сложностью O(n), то общая сложность будет O(n^2).

4. Избегайте некорректных оценок: Убедитесь, что ваша оценка Big O является верхней границей для сложности алгоритма.
Например, если вы выполняете сортировку массива, нельзя оценить сложность как O(n^3), если алгоритм может быть выполнен
за O(n log n).

### Ниже приведены примеры оценки сложности алгоритмов на C++:

#### Линейная сложность (O(n)):
```cpp
void linearAlgorithm(int n) {
    for (int i = 0; i < n; i++) {
    // Базовая операция с линейной сложностью
        cout << i << endl;
    }
}
```
#### Квадратичная сложность (O(n^2)):
```cpp
void quadraticAlgorithm(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // Базовая операция с квадратичной сложностью
            cout << i + j << endl;
        }
    }
}
```
#### Логарифмическая сложность (O(log n)):
```cpp
void logarithmicAlgorithm(int n) {
int i = n;
    while (i > 0) {
        // Базовая операция с логарифмической сложностью
        cout << i << endl;
        i /= 2;
    }
}
```
#### Константная сложность (O(1)):
```cpp
void constantAlgorithm() {
    // Базовая операция с постоянной сложностью
    cout << "Hello, world!" << endl;
}
```
Важно понимать, что эти примеры демонстрируют только оценку временной сложности алгоритмов, и использование конкретных
структур данных и алгоритмов может изменить их фактическую производительность.

